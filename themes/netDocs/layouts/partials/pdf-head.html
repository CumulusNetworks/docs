
<script>
    (function () {
      // Baseline counts at install time
      const baselineSheets = document.styleSheets.length;
      let finished = false;
      const START = Date.now();
      const MAX_WAIT_MS = 15000; // safety cap
    
      // Optional: if your CSS-in-JS inserts a marker, set this to match it.
      // e.g., styled-components: style[data-styled="active"]
      //       emotion: style[data-emotion]
      const MARKERS = [
        'style[data-styled]',
        'style[data-styled="active"]',
        'style[data-emotion]',
        'style[data-docs-generated]', // add this if you control the injector
      ];
    
      function hasMarker() {
        for (const sel of MARKERS) {
          if (document.querySelector(sel)) return true;
        }
        return false;
      }
    
      function cssReady() {
        // New stylesheet appeared OR we see a known marker
        const newSheets = document.styleSheets.length > baselineSheets;
        return newSheets || hasMarker();
      }
    
      // Mutation observer to detect <style>/<link rel="stylesheet"> inserts
      const observer = new MutationObserver(() => {
        if (cssReady()) {
          finished = true;
          observer.disconnect();
        }
      });
    
      // Observe head (most CSS injectors target <head>)
      try {
        observer.observe(document.head || document.documentElement, {
          childList: true,
          subtree: true
        });
      } catch (e) {
        // Do not let this break page execution
      }
    
      // Fallback: keep polling lightly (handles cases where styleSheets updates
      // without a DOM mutation we can catch)
      const poll = () => {
        if (!finished && cssReady()) finished = true;
        if (!finished && (Date.now() - START) < MAX_WAIT_MS) {
          setTimeout(poll, 100);
        }
      };
      poll();
    
      // Fonts (optional; guard to avoid errors)
      try {
        if (document.fonts && document.fonts.status !== 'loaded') {
          document.fonts.ready.then(() => {
            if (cssReady()) finished = true;
          }).catch(() => {});
        }
      } catch (e) {}
    
      // The only function DocRaptor reads. Must return a strict boolean.
      window.docraptorJavaScriptFinished = function () {
        if (!finished && (Date.now() - START) > MAX_WAIT_MS) {
          // Don't hang forever; you can tighten/loosen this cap
          finished = cssReady();
        }
        return finished === true;
      };
    })();
    </script>
    
      
  

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>


<script>
    function expand_tabs_singlepage() {
      // For every tab group on the page
      $('.book-tabs').each(function () {
        const $group = $(this);
        const sections = [];
  
        // Each radio represents one tab; pair it with its label and content
        $group.find('input[type=radio]').each(function () {
          const $input = $(this);
          const $label = $input.next('label');
          const $content = $input.nextAll('.book-tabs-content').first();
  
          if ($label.length && $content.length) {
            // Clone to avoid reparenting original nodes (safer for other scripts)
            const $labelClone = $label.clone();
            const $contentClone = $content.clone();
  
            // Make sure content is visible in single-page mode
            $contentClone.show();
  
            // Normalize label styling for a header feel in single-page mode
            $labelClone
              .removeAttr('for')                // not a control anymore
              .css({
                display: 'block',
                'border-bottom': '0',
                'font-weight': 600,
                'margin': '24px 0 8px',
                'cursor': 'default'
              })
              .addClass('tab-title');           // optional hook if you want custom CSS
  
            // Assemble a new section with label ABOVE content
            const $section = $('<div class="book-tabs section"></div>');
            $section.append($labelClone).append($contentClone);
  
            sections.push($section);
          }
        });
  
        // Replace the original tab group with the new stacked sections
        // (If you prefer a single container, wrap sections in one div instead.)
        if (sections.length) {
          $group.replaceWith(sections);
        } else {
          // Fallback: if no radios found, still show content in-place
          $group.find('.book-tabs-content').show();
          $group.find('input[type=radio]:checked+label').css('border-bottom', '0');
        }
      });
  
      // Optional: clean up any stray inputs (if cloning isn't used)
      // $('.book-tabs input[type=radio]').remove();
    }
  
    // Run on load
    window.addEventListener('load', expand_tabs_singlepage);
  </script>


<meta name="author" content="Cumulus Networks" />
<meta name="keywords" content="COMMIT_INFO" />
<meta name="search_visibility" content="hidden" />
<meta name="robots" content="noindex">

<style type="text/css">
    @page {
      /* NetQ docs contain long outputs.
      Use landscape style to help fit */
      {{ if eq .Page.Params.product "Cumulus NetQ" }}
          size: A4 landscape;
      {{ else }}
          size: A4 portrait;
      {{ end }}

      @bottom {
          padding-top: 0;
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #36424a;
      }
      @top-right {
        border-bottom: .25pt solid #36424a;
      }

  }

  @page:right {
      @bottom {
          content: {{.Site.Params.baseURL}}
      }

      @bottom-right {
          padding-top: 0;
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #36424a;
          content: counter(page);
      }

      @bottom-left {
          padding-top: 0;
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #36424a;
      }

      @top-right {
          padding-bottom: 0;
          margin: 10pt 0 30pt 0;
          border-bottom: .25pt solid #36424a;
          content: "{{.Page.Params.product}} v{{.Page.Params.version}} User Documentation";
      }

      @top-left {
          padding-bottom: 0;
          margin: 10pt 0 30pt 0;
          content: string(chapter-title);
          border-bottom: .25pt solid #36424a;
      }
  }

  @page:left {
      @bottom {
          content: "{{.Site.Params.BaseURL}}"
      }

      @bottom-right {
          padding-top: 0;
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #36424a;
      }

      @bottom-left {
          padding-top: 0;
          margin: 10pt 0 30pt 0;
          border-top: .25pt solid #36424a;
          content: counter(page);
      }

      @top-right {
          padding-bottom: 0;
          margin: 10pt 0 30pt 0;
          border-bottom: .25pt solid #36424a;
          content: string(chapter-title);
      }

      @top-left {
          padding-bottom: 0;
          margin: 10pt 0 30pt 0;
          border-bottom: .25pt solid #36424a;
          content: "{{.Page.Params.product}} v{{.Page.Params.version}} User Documentation";
      }

  }

  @page:first {
      @bottom-right {
          content: normal;
      }
      @bottom-left {
          content: normal;
      }
      @bottom {
          content: normal;
      }
      @top-right {
          content: normal;
      }
      @top-left {
          content: normal;
      }
      @top {
          content: normal;
      }
  }
  .book-page {
      counter-reset: page 1
  }

  #cover {
      width: 100%;
      text-align: center;
      break-after: always;
  }

  #centered {
      break-after: always;
      margin: 0 auto;
      display: inline-block;
      padding: 3px;
  }

  #centered h1 {
      color: #36424a;
      font-size: 2rem;
      font-weight: 300;
      letter-spacing: -.7px;
      line-height: 3rem;
      margin-top: 0;
      margin-bottom: 1.1rem
  }

  #centered img {
      display: block;
      page-break-inside: avoid;
      width: 500px;
      height: auto;
      margin: auto;
  }

  img {
    padding-bottom: 30px;
  }

  .markdown {
      page-break-after: always;
  }

  .markdown code {
    font-size: .8rem;
  }

  .markdown pre {
    white-space: pre-wrap;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
  .toc1 {
      prince-bookmark-level: 1;
  }

  .toc2 {
      prince-bookmark-level: 2;
      string-set: chapter-title content()
  }

  .toc3 {
      prince-bookmark-level: 3;
  }

  h1 {
      prince-bookmark-level: none;
  }

  h2 {
      prince-bookmark-level: none;
  }

  h3 {
      prince-bookmark-level: none;
  }

  h4 {
      prince-bookmark-level: none;
  }
</style>